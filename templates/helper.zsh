# list all zsh functions
function funcs() {
  local allfuncs
  for file in $ZFUNCS_PATH/*
  do
    local filename=${file##*"/"}
    if [[ $filename != *".zsh"* ]]; then
      continue
    fi
    allfuncs="$allfuncs\n${CYAN}\n$filename${NOCOLOR}"
    local contents=$(cat $file | rg -v "#noface" | rg -B 1 "(function)( ).*(\()" | rg -v -e "--")
    lines=("${(@f)contents}")
    for line in $lines
    do
      if [[ $line == *"#"* ]]; then
        local comment=${line##*"# "}
        tag=" : $comment"
      else
        local trimend=$(cut -d " " -f2 <<< $line)
        local name=${trimend%%"("*}
        allfuncs="$allfuncs\n${CYAN}- ${YELLOW}$name${NOCOLOR}$tag"
        tag=" : ${RED}no description available${NOCOLOR}"
      fi
    done
  done
  if [[ $1 == "" ]]; then
    echo $allfuncs
  else
    echo $allfuncs | rg $1
  fi
  echo ""
}

function zfunchelp() { #noface
  local cmd=$1
  if [[ $cmd == 'zimon' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- initialization and update of simon-zfuncs"
    echo "\n${GREEN}usage:${NOCOLOR}"
    echo "- ${LIGHTGREEN}simon ${YELLOW}<command> ${BLUE}[options]${NOCOLOR}"
    echo "\n${GREEN}commands:${NOCOLOR}"
    echo "- [ ${YELLOW}init${NOCOLOR} ] : initialize simon-zfuncs and Bellese DevOps working environment"
    echo "      ${BLUE}--no-creds${NOCOLOR} : initialize without updating ADFS id and password"
    echo "- [ ${YELLOW}update${NOCOLOR} ] : update simon-zfuncs to use latest code"
    echo ""
  elif [[ $cmd == 'thisaws' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- print current aws account and workspace"
    echo ""
  elif [[ $cmd == 'stl' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- check if current or specific aws profile is still active"
    echo "\n${GREEN}environment options:${NOCOLOR}"
    echo "- [ ${LIGHTYELLOW}sbx, dev, test, impl, prod${NOCOLOR} ]"
    echo "\n${GREEN}usage:${NOCOLOR}"
    echo "- ${LIGHTGREEN}stl ${BLUE}[option] ${YELLOW}<environment>${NOCOLOR}"
    echo "\n${GREEN}arguments:${NOCOLOR}"
    echo "- [ ${YELLOW}environment${NOCOLOR} ] : ${LAV}optional${NOCOLOR} - if empty, check the status of the current account of the environment variable AWS_PROFILE"
    echo "\n${GREEN}options:${NOCOLOR}"
    echo "  [ ${BLUE}--refresh, -r${NOCOLOR} ] : if set, trigger stsauth when remaining time is lower than 10 minutes"
    echo ""
  elif [[ $cmd == 'awsprof' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- switch to an aws account and workspace and refresh if profile is expired"
    echo "\n${GREEN}account options:${NOCOLOR}"
    echo "- [ ${LIGHTYELLOW}service, sbx, dev, test, impl, prod${NOCOLOR} ]"
    echo "\n${GREEN}workspace options:${NOCOLOR}"
    echo "- [ ${LIGHTYELLOW}sbx, dev, test, prod, default${NOCOLOR} ]"
    echo "\n${GREEN}usage:${NOCOLOR}"
    echo "- ${LIGHTGREEN}awsprof ${YELLOW}<account> <workspace>${NOCOLOR}"
    echo "\n${GREEN}arguments:${NOCOLOR}"
    echo "- [ ${YELLOW}account${NOCOLOR} ] : desired account to assume"
    echo "- [ ${YELLOW}workspace${NOCOLOR} ] : ${LAV}optional${NOCOLOR} - desired workspace. if empty, selects the same workspace as the account argument. Not compatible with account set to 'service'"
    echo ""
  elif [[ $cmd == 'gcm' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- checkout master or main"
    echo
  elif [[ $cmd == 'gpm' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- pull from master or main"
    echo
  elif [[ $cmd == 'grh' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- git reset and remove tf lock if applicable"
    echo
  elif [[ $cmd == 'gco' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- search remote branches and checkout branch that matches the filter"
    echo "\n${GREEN}usage:${NOCOLOR}"
    echo "- ${LIGHTGREEN}gco ${YELLOW}[filter...]${NOCOLOR}"
    echo "\n${GREEN}arguments:${NOCOLOR}"
    echo "- [ ${YELLOW}filter${NOCOLOR} ] : list of words that the desired branch contains"
    echo "\n${GREEN}example:${NOCOLOR}"
    echo "  ${LIGHTGREEN}gco ${LIGHTYELLOW}epic aws account${NOCOLOR} : this will search for remote branches that contain the words 'epic', 'aws', and 'account' and checkout the first matching branch"
    echo ""
  elif [[ $cmd == 'gitc' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- clone github repository to $PROJECT_PATH"
    echo "\n${GREEN}usage:${NOCOLOR}"
    echo "- ${LIGHTGREEN}gitc ${YELLOW}<address>${NOCOLOR}"
    echo "\n${GREEN}arguments:${NOCOLOR}"
    echo "- [ ${YELLOW}address${NOCOLOR} ] : URL address of the desired github repository"
    echo ""
  elif [[ $cmd == 'gnb' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- create new branch"
    echo "\n${GREEN}usage:${NOCOLOR}"
    echo "- ${LIGHTGREEN}gnb ${YELLOW}<name>${NOCOLOR}"
    echo "\n${GREEN}arguments:${NOCOLOR}"
    echo "- [ ${YELLOW}name${NOCOLOR} ] : desired name of the branch to be created"
    echo ""
  elif [[ $cmd == 'gdb' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- delete branch"
    echo "\n${GREEN}usage:${NOCOLOR}"
    echo "- ${LIGHTGREEN}gdb ${YELLOW}<name>${NOCOLOR}"
    echo "\n${GREEN}arguments:${NOCOLOR}"
    echo "- [ ${YELLOW}name${NOCOLOR} ] : name of the branch to be deleted"
    echo ""
  elif [[ $cmd == 'gdbm' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- delete the current branch, checkout the master or main branch, and pull from remote"
    echo ""
  elif [[ $cmd == 'gpr' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- create pull request from current branch to target branch, default to master"
    echo "\n${GREEN}usage:${NOCOLOR}"
    echo "- ${LIGHTGREEN}gpr ${YELLOW}<target>${NOCOLOR}"
    echo "\n${GREEN}arguments:${NOCOLOR}"
    echo "- [ ${YELLOW}target${NOCOLOR} ] : ${LAV}optional${NOCOLOR} - name of the branch to target with the created pull request, defaults to 'master'"
    echo ""
  elif [[ $cmd == 'gcom' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- git add and commit with the provided commit message"
    echo "\n${GREEN}usage:${NOCOLOR}"
    echo "- ${LIGHTGREEN}gcom ${YELLOW}[message...]${NOCOLOR}"
    echo "\n${GREEN}arguments:${NOCOLOR}"
    echo "- [ ${YELLOW}message${NOCOLOR} ] : commit message to use with git commit"
    echo "\n${GREEN}example:${NOCOLOR}"
    echo "  ${LIGHTGREEN}gcom ${LIGHTYELLOW}example commit message${NOCOLOR} : this will git add all changed files and git commit using the commit message 'example commit message'"
    echo ""
  elif [[ $cmd == 'gopen' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- open the current project's github repo on the current branch"
    echo ""
  elif [[ $cmd == 'grls' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- search and list all Bellese repositories that matches the filter"
    echo "\n${GREEN}usage:${NOCOLOR}"
    echo "- ${LIGHTGREEN}grls ${YELLOW}[filter...]${NOCOLOR}"
    echo "\n${GREEN}arguments:${NOCOLOR}"
    echo "- [ ${YELLOW}filter${NOCOLOR} ] : list of words with which to filter the remote github repositories"
    echo "\n${GREEN}example:${NOCOLOR}"
    echo "  ${LIGHTGREEN}grls ${LIGHTYELLOW}sfs file router${NOCOLOR} : this will return a list of all Bellese repositories that contain the words 'sfs', 'file', and 'router"
    echo ""
  elif [[ $cmd == 'grclone' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- search for repositories in the Bellese github using the filter and clone. This function will confirm with the user that the found repository is the desired repository."
    echo "\n${GREEN}input:${NOCOLOR}"
    echo "- confirm: [ PRESS ENTER ]"
    echo "- reject: [ PRESS ANYTHING ELSE ]"
    echo "\n${GREEN}usage:${NOCOLOR}"
    echo "- ${LIGHTGREEN}grclone ${YELLOW}[filter...]${NOCOLOR}"
    echo "\n${GREEN}arguments:${NOCOLOR}"
    echo "- [ ${YELLOW}filter${NOCOLOR} ] : list of words with which to filter the remote github repositories"
    echo "\n${GREEN}example:${NOCOLOR}"
    echo "  ${LIGHTGREEN}grclone ${LIGHTYELLOW}sfs file router${NOCOLOR} : this will search for Bellese repositories that contain 'sfs', 'file', and 'router', show a list of matching repositories, and prompt the user to confirm cloning of the first found repository."
    echo ""
  elif [[ $cmd == 'gtfpull' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- sync terraform projects with the remote by performing git pull on terraform projects on the epic branch. If the type argument is set to 'service', this function will check service environment projects on the master branch"
    echo "\n${GREEN}usage:${NOCOLOR}"
    echo "- ${LIGHTGREEN}gtfpull ${YELLOW}<type>${NOCOLOR}"
    echo "\n${GREEN}arguments:${NOCOLOR}"
    echo "- [ ${YELLOW}type${NOCOLOR} ] : ${LAV}optional${NOCOLOR} - set to 'service' to check service environment projects"
    echo ""
  elif [[ $cmd == 'gepicprecommit' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- update precommits on all projects on the epic branch and push to remote"
    echo ""
  elif [[ $cmd == 'gtfmoduleversion' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- search for all usages of a module that matches the filter word"
    echo "\n${GREEN}usage:${NOCOLOR}"
    echo "- ${LIGHTGREEN}gtfmoduleversion ${YELLOW}<type> <version>${NOCOLOR}"
    echo "\n${GREEN}arguments:${NOCOLOR}"
    echo "- [ ${YELLOW}type${NOCOLOR} ] : target type of aws resource terraform module"
    echo "- [ ${YELLOW}version${NOCOLOR} ] : ${LAV}optional${NOCOLOR} - version with which to compare the found module versions"
    echo "\n${GREEN}examples:${NOCOLOR}"
    echo "  ${LIGHTGREEN}gtfmoduleversion ${LIGHTYELLOW}rds${NOCOLOR} : this will search in all terraform projects for an 'rds' module and output the name of the project, the current branch of the project, the file in which the module exists, the name of the module itself, and the version of the module."
    echo "  ${LIGHTGREEN}gtfmoduleversion ${LIGHTYELLOW}sqs 1.0.0${NOCOLOR} : this will search in all terraform projects for an 'sqs' module and output the name of the project, the current branch of the project, the file in which the module exists, the name of the module itself, and the version of the module. If the version of the module does not match '1.0.0', the version will be red in color."
    echo ""
  elif [[ $cmd == 'comparetfs' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- search github terraform repositories and compare with locally cloned projects"
    echo ""
  elif [[ $cmd == 'vipcp' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- generate a vipaccess code and copy it to the clipboard"
    echo ""
  elif [[ $cmd == 'findp' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- search all projects' contents in the project's directory for the filter."
    echo "\n${GREEN}supported file types:${NOCOLOR}"
    echo "- [ ${LIGHTYELLOW}.tf, .tfvars, .mod, Jenkinsfile${NOCOLOR} ]"
    echo "\n${GREEN}usage:${NOCOLOR}"
    echo "- ${LIGHTGREEN}findp ${YELLOW}<option> [filter...]${NOCOLOR}"
    echo "\n${GREEN}options:${NOCOLOR}"
    echo "- [ ${YELLOW}--all${NOCOLOR} ] : checks all files regardles of file type. This option only supports one word filter searches"
    echo "\n${GREEN}arguments:${NOCOLOR}"
    echo "- [ ${YELLOW}filter${NOCOLOR} ] : list of words which the results should include"
    echo "\n${GREEN}example:${NOCOLOR}"
    echo "  ${LIGHTGREEN}findp ${LIGHTYELLOW}cell name${NOCOLOR} : this will search for lines in every file in the projects directory that contain the words 'cell' and 'name'"
    echo ""
  elif [[ $cmd == 'listp' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- search projects in the projects directory and return the ones that match the filter."
    echo "\n${GREEN}usage:${NOCOLOR}"
    echo "- ${LIGHTGREEN}listp ${BLUE}[option]${NOCOLOR} ${YELLOW}[filter...]${NOCOLOR}"
    echo "\n${GREEN}options:${NOCOLOR}"
    echo "- [ ${BLUE}--no-color${NOCOLOR} ] : disables colors in the ripgrep results"
    echo "\n${GREEN}arguments:${NOCOLOR}"
    echo "- [ ${YELLOW}filter${NOCOLOR} ] : list of words which the results should include"
    echo "\n${GREEN}example:${NOCOLOR}"
    echo "  ${LIGHTGREEN}listp ${LIGHTYELLOW}sfs file router${NOCOLOR} : this will return a list of project names that contain the words 'sfs', 'file', and 'router'"
    echo ""
  elif [[ $cmd == 'iop' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- search for projects that match the filter and open it in IntelliJ. This function will confirm with the user that the found repository is the desired repository."
    echo "\n${GREEN}input:${NOCOLOR}"
    echo "- confirm: [ PRESS ENTER ]"
    echo "- reject: [ PRESS ANYTHING ELSE ]"
    echo "\n${GREEN}usage:${NOCOLOR}"
    echo "- ${LIGHTGREEN}iop ${BLUE}<option> ${LIGHTYELLOW}[filter...]${NOCOLOR}"
    echo "\n${GREEN}options:${NOCOLOR}"
    echo "- [ ${BLUE}--vs${NOCOLOR} ] : force use of vscode, regardless of default IDE"
    echo "- [ ${BLUE}--ij${NOCOLOR} ] : force use of intellij, regardless of default IDE"
    echo "\n${GREEN}arguments:${NOCOLOR}"
    echo "- [ ${LIGHTYELLOW}filter${NOCOLOR} ] : list of words which the desired project should include"
    echo "\n${GREEN}example:${NOCOLOR}"
    echo "  ${LIGHTGREEN}iop ${LIGHTYELLOW}sfs file router${NOCOLOR} : this will return a list of project names that contain the words 'sfs', 'file', 'router', and prompt the user to confirm opening of the first found repository."
    echo "  ${LIGHTGREEN}iop ${BLUE}--vs ${LIGHTYELLOW}sfs file router${NOCOLOR} : this will behave in the same way as the previous example, but it will open the project in VSCode"
    echo ""
  elif [[ $cmd == 'cdpr' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- search the projects directory that match the filter and cd into the result."
    echo "\n${GREEN}usage:${NOCOLOR}"
    echo "- ${LIGHTGREEN}cdpr ${YELLOW}[filter...]${NOCOLOR}"
    echo "\n${GREEN}arguments:${NOCOLOR}"
    echo "- [ ${YELLOW}filter${NOCOLOR} ] : list of words which the desired project should include"
    echo "\n${GREEN}example:${NOCOLOR}"
    echo "  ${LIGHTGREEN}cdpr ${LIGHTYELLOW}sfs file router${NOCOLOR} : this will return a list of project names that contain the words 'sfs', 'file', 'router', and cd into the first result."
    echo ""
  elif [[ $cmd == 'showcolors' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- show currently used colors"
    echo ""
  elif [[ $cmd == 'coloropts' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- print all colors available with oh-my-zsh"
    echo ""
  elif [[ $cmd == 'clup' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- initialize precommit, check for unused terraform variables, and run precommit"
    echo ""
  elif [[ $cmd == 'tfp' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- terraform plan"
    echo "\n${GREEN}usage:${NOCOLOR}"
    echo "- ${LIGHTGREEN}tfp ${BLUE}[option]${NOCOLOR} ${YELLOW}[append...]${NOCOLOR}"
    echo "\n${GREEN}options:${NOCOLOR}"
    echo "- [ ${BLUE}autover${NOCOLOR} ] : ${LAV}optional${NOCOLOR} - uses the variables exported from 'getver'"
    echo "\n${GREEN}arguments:${NOCOLOR}"
    echo "- [ ${YELLOW}append${NOCOLOR} ] : terraform plan appendages"
    echo "\n${GREEN}example:${NOCOLOR}"
    echo "  ${LIGHTGREEN}tfp ${BLUE}autover ${LIGHTYELLOW}-target module.postgres${NOCOLOR} : this will run '${LIGHTGREEN}terraform plan${NOCOLOR}', append '${LIGHTYELLOW}-target module.postgres${NOCOLOR}' to the command, and use the list of vars in the environment variable TFP_VARS. For example, if the output of 'getver' exports '-var container_image_version=1.0.0', this command will append '-var container_image_version=1.0.0' to the terraform plan command."
    echo ""
  elif [[ $cmd == 'tfa' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- terraform apply"
    echo "\n${GREEN}usage:${NOCOLOR}"
    echo "- ${LIGHTGREEN}tfa ${YELLOW}[append...]${NOCOLOR}"
    echo "\n${GREEN}arguments:${NOCOLOR}"
    echo "- [ ${YELLOW}append${NOCOLOR} ] : terraform apply appendages"
    echo "\n${GREEN}example:${NOCOLOR}"
    echo "  ${LIGHTGREEN}tfa ${LIGHTYELLOW}-no-color${NOCOLOR} : this will run '${LIGHTGREEN}terraform apply${NOCOLOR}', and append '${LIGHTYELLOW}-no-color${NOCOLOR}' to the command."
    echo ""
  elif [[ $cmd == 'tfd' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- terraform destroy"
    echo "\n${GREEN}usage:${NOCOLOR}"
    echo "- ${LIGHTGREEN}tfd ${BLUE}[option]${NOCOLOR} ${YELLOW}[append...]${NOCOLOR}"
    echo "\n${GREEN}options:${NOCOLOR}"
    echo "- [ ${BLUE}autover${NOCOLOR} ] : ${LAV}optional${NOCOLOR} - uses the variables exported from 'getver'"
    echo "\n${GREEN}arguments:${NOCOLOR}"
    echo "- [ ${YELLOW}append${NOCOLOR} ] : terraform destroy appendages"
    echo "\n${GREEN}example:${NOCOLOR}"
    echo "  ${LIGHTGREEN}tfd ${BLUE}autover ${LIGHTYELLOW}-target module.postgres${NOCOLOR} : this will run '${LIGHTGREEN}terraform destroy${NOCOLOR}', append '${LIGHTYELLOW}-target module.postgres${NOCOLOR}' to the command, and use the list of vars in the environment variable TFP_VARS. For example, if the output of 'getver' exports '-var container_image_version=1.0.0', this command will append '-var container_image_version=1.0.0' to the terraform plan command."
    echo ""
  elif [[ $cmd == 'tfr' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- terraform state refresh"
    echo ""
  elif [[ $cmd == 'tfsl' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- terraform state list"
    echo ""
  elif [[ $cmd == 'tfw' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- terraform workspace commands"
    echo "\n${GREEN}environment options:${NOCOLOR}"
    echo "- [ ${LIGHTYELLOW}sbx, dev, test, prod${NOCOLOR} ]"
    echo "\n${GREEN}command options:${NOCOLOR}"
    echo "- [ ${BLUE}list, show, ${ORANGE}new, delete${NOCOLOR} ]"
    echo "\n${GREEN}usage:${NOCOLOR}"
    echo "- ${LIGHTGREEN}tfw ${YELLOW}<environment>${NOCOLOR}"
    echo "- ${LIGHTGREEN}tfw ${BLUE}<command>${NOCOLOR}"
    echo "- ${LIGHTGREEN}tfw ${ORANGE}<command> ${YELLOW}<name>${NOCOLOR}"
    echo "\n${GREEN}arguments:${NOCOLOR}"
    echo "- [ ${YELLOW}environment${NOCOLOR} ] : terraform workspace to assume"
    echo "- [ ${YELLOW}command${NOCOLOR} ] : terraform workspace command to run"
    echo "- [ ${YELLOW}name${NOCOLOR} ] : terraform workspace to affect"
    echo ""
  elif [[ $cmd == 'restf' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- reset the local terraform workspace."
    echo "\n${GREEN}environment options:${NOCOLOR}"
    echo "- [ ${LIGHTYELLOW}sbx, dev, test, prod${NOCOLOR} ]"
    echo "\n${GREEN}usage:${NOCOLOR}"
    echo "- ${LIGHTGREEN}restf ${YELLOW}<environment>${NOCOLOR}"
    echo "\n${GREEN}arguments:${NOCOLOR}"
    echo "- [ ${YELLOW}environment${NOCOLOR} ] : ${LAV}optional${NOCOLOR} - terraform workspace to assume. If not provided, uses the environment of the aws account set for AWS_PROFILE"
    echo ""
  elif [[ $cmd == 'tfstls' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- search and return a list of terraform state resources that match the filters."
    echo "\n${GREEN}usage:${NOCOLOR}"
    echo "- ${LIGHTGREEN}tfstls ${YELLOW}<option> [filter...]${NOCOLOR}"
    echo "\n${GREEN}options:${NOCOLOR}"
    echo "- [ ${YELLOW}--no-color${NOCOLOR} ] : disables colors in the output of matching resources"
    echo "\n${GREEN}arguments:${NOCOLOR}"
    echo "- [ ${YELLOW}filter${NOCOLOR} ] : list of words that the desired resource contains"
    echo "\n${GREEN}example:${NOCOLOR}"
    echo "  ${LIGHTGREEN}tfstls${YELLOW} module ecs task${NOCOLOR} : this will return a list of terraform state resources that contain the words 'module', 'ecs', and 'task'"
    echo ""
  elif [[ $cmd == 'tfstget' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- search and get the terraform state resource that matches the filters."
    echo "\n${GREEN}usage:${NOCOLOR}"
    echo "- ${LIGHTGREEN}tfstget ${YELLOW}[filter...]${NOCOLOR}"
    echo "\n${GREEN}arguments:${NOCOLOR}"
    echo "- [ ${YELLOW}filter${NOCOLOR} ] : list of words that the desired resource contains"
    echo "\n${GREEN}example:${NOCOLOR}"
    echo "  ${LIGHTGREEN}tfstget${YELLOW} module ecs task${NOCOLOR} : this will return the first terraform state resource with a name that contains the words 'module', 'ecs', and 'task'"
    echo ""
  elif [[ $cmd == 'tfstgets' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- search and get all terraform state resources that matches the filters. This function will confirm with the user that the found resource is the desired resource."
    echo "\n${GREEN}input:${NOCOLOR}"
    echo "- confirm: [ PRESS ENTER ]"
    echo "- reject: [ PRESS ANYTHING ELSE ]"
    echo "\n${GREEN}usage:${NOCOLOR}"
    echo "- ${LIGHTGREEN}tfstgets ${YELLOW}[filter...]${NOCOLOR}"
    echo "\n${GREEN}arguments:${NOCOLOR}"
    echo "- [ ${YELLOW}filter${NOCOLOR} ] : list of words that the desired resource contains"
    echo "\n${GREEN}example:${NOCOLOR}"
    echo "  ${LIGHTGREEN}tfstgets${YELLOW} module ecs task${NOCOLOR} : this will return every terraform state resource with a name that contains the words 'module', 'ecs', and 'task'"
    echo ""
  elif [[ $cmd == 'getver' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- get the image version or s3 keys of the current project's main resource(s)."
    echo "\n${GREEN}type options:${NOCOLOR}"
    echo "- [ ${LIGHTYELLOW}ms, fn${NOCOLOR} ]"
    echo "\n${GREEN}usage:${NOCOLOR}"
    echo "- ${LIGHTGREEN}getver ${YELLOW}<type> <resource>${NOCOLOR}"
    echo "\n${GREEN}arguments:${NOCOLOR}"
    echo "- [ ${YELLOW}type${NOCOLOR} ] : ${LAV}optional${NOCOLOR} - the type of the main resource in the project. If this is not provided, it is deteremined using the name of the project."
    echo "- [ ${YELLOW}resource${NOCOLOR} ] : ${LAV}optional${NOCOLOR} - the name of the desired resource in the project. If this is not provided, it is assumed that there is only one instance of the desired type."
    echo "\n${GREEN}example:${NOCOLOR}"
    echo "  ${LIGHTGREEN}getver${NOCOLOR} : this will search the current project for the main resource's currently deployed version and use the project's name to determine if the main resource is a microservice or a lambda function. The version(s) of the resource is exported to the environment variable called TFP_VARS. Running 'tfp autover' will use the values in TFP_VARS that are exported from this function."
    echo "  ${LIGHTGREEN}getver ${YELLOW}ms${NOCOLOR} : this will search the current project for the currently deployed microservice's container image version and export the value to TFP_VARS for use with 'tfp autover'"
    echo ""
  elif [[ $cmd == 'getverenv' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- gets image version or s3 key in different environment"
    echo "\n${GREEN}environment options:${NOCOLOR}"
    echo "- [ ${LIGHTYELLOW}sbx, dev, test, prod${NOCOLOR} ]"
    echo "\n${GREEN}type options:${NOCOLOR}"
    echo "- [ ${LIGHTYELLOW}ms, fn${NOCOLOR} ]"
    echo "\n${GREEN}usage:${NOCOLOR}"
    echo "- ${LIGHTGREEN}getverenv ${YELLOW}<environment> <type> <resource>${NOCOLOR}"
    echo "\n${GREEN}arguments:${NOCOLOR}"
    echo "- [ ${YELLOW}environment${NOCOLOR} ] : ${LAV}optional${NOCOLOR} - the type of the main resource in the project. If this is not provided, it is deteremined using the name of the project."
    echo "- [ ${YELLOW}type${NOCOLOR} ] : ${LAV}optional${NOCOLOR} - the type of the main resource in the project. If this is not provided, it is deteremined using the name of the project."
    echo "- [ ${YELLOW}type${NOCOLOR} ] : ${LAV}optional${NOCOLOR} - the type of the main resource in the project. If this is not provided, it is deteremined using the name of the project."
    echo "\n${RED}warning:${NOCOLOR}"
    echo "- This function does not yet support searching for lambda function s3 keys in the 'prod' and 'test' environments."
    echo "\n${GREEN}example:${NOCOLOR}"
    echo "  ${LIGHTGREEN}getverenv ${YELLOW}sbx sfs-backend${NOCOLOR} : this will search the sbx account, and assuming the current project is a microservice, will return the container image version on an ECS service with the word 'sfs-backend' in its name, and export that value to the environment variable TFP_VARS for use with 'tfp autover'."
    echo "  ${LIGHTGREEN}getverenv ${YELLOW}prod fn sfs-backend${NOCOLOR} : this will return an error message and perform nothing, as 'fn' is an invalid type to search on the 'prod' and 'test' environments."
    echo ""
  elif [[ $cmd == 'tftg' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- gets the module/resource/data name in the current project's .tf files"
    echo "\n${GREEN}usage:${NOCOLOR}"
    echo "- ${LIGHTGREEN}tftg ${YELLOW}[filter...]${NOCOLOR}"
    echo "\n${GREEN}arguments:${NOCOLOR}"
    echo "- [ ${YELLOW}filter${NOCOLOR} ] : list of words that the desired resource contains"
    echo "\n${GREEN}example:${NOCOLOR}"
    echo "  ${LIGHTGREEN}tftg ${LIGHTYELLOW}s3 access${NOCOLOR} : this will search the current project's .tf files and find the module/resource/data block that contains the words 's3' and 'access' in the name, and depending on the type of block, will copy the target appendage to the clipboard. eg: -target resource.aws_s3_bucket.s3_public_access"
    echo ""
  elif [[ $cmd == 'datadeps' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- get a list of resources created in a desired branch and dependencies that the project relies on."
    echo "\n${GREEN}branch options:${NOCOLOR}"
    echo "- [ ${LIGHTYELLOW}master epic${NOCOLOR} ]"
    echo "\n${GREEN}usage:${NOCOLOR}"
    echo "- ${LIGHTGREEN}datadeps ${YELLOW}<branch> [filter...]${NOCOLOR}"
    echo "\n${GREEN}arguments:${NOCOLOR}"
    echo "- [ ${YELLOW}branch${NOCOLOR} ] : list of words that the desired resource contains"
    echo "- [ ${YELLOW}filter${NOCOLOR} ] : list of words that the desired project contains"
    echo "\n${GREEN}example:${NOCOLOR}"
    echo "  ${LIGHTGREEN}datadeps ${LIGHTYELLOW}epic sfs file${NOCOLOR} : this will search the project's directory for a project that contains the words 'sfs' and 'file' and search the epic branch for a list of resources that are created and a list of dependencies that the project needs on that branch."
    echo ""
  elif [[ $cmd == 'getgravemigrated' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- print migrated resources, use in graveyard project"
    echo "\n${GREEN}usage:${NOCOLOR}"
    echo "- ${LIGHTGREEN}getgravemigrated ${YELLOW}<environment>${NOCOLOR}"
    echo "\n${GREEN}arguments:${NOCOLOR}"
    echo "- [ ${YELLOW}environment${NOCOLOR} ] : environment on which to check if migrated resources exist"
    echo ""
  elif [[ $cmd == 'showecs' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- prints a list of currently deployed ECS services' container image version or security group(s) for a given environment"
    echo "\n${GREEN}environment options:${NOCOLOR}"
    echo "- [ ${LIGHTYELLOW}sbx, dev, test, prod${NOCOLOR} ]"
    echo "\n${GREEN}type options:${NOCOLOR}"
    echo "- [ ${LIGHTYELLOW}version, security${NOCOLOR} ]"
    echo "\n${GREEN}usage:${NOCOLOR}"
    echo "- ${LIGHTGREEN}showecs ${YELLOW}<account> <environment> <type> ${NOCOLOR}"
    echo "\n${GREEN}arguments:${NOCOLOR}"
    echo "- [ ${YELLOW}account${NOCOLOR} ] : desired account to check the current deployed ECS versions"
    echo "- [ ${YELLOW}environment${NOCOLOR} ] : ${LAV}optional${NOCOLOR} - desired environment to check the current deployed ECS versions"
    echo "- [ ${YELLOW}type${NOCOLOR} ] : desired value type to display on each ECS service"
    echo "\n${GREEN}example:${NOCOLOR}"
    echo "  ${LIGHTGREEN}showecs ${LIGHTYELLOW}prod test version${NOCOLOR} : this will check the currently deployed container image versions on the PROD account's TEST ECS clusters."
    echo "  ${LIGHTGREEN}showecs ${LIGHTYELLOW}sbx version${NOCOLOR} : this will check the current deployed container image versions on the SBX account's ECS clusters. The 'environment' argument is unnecessary because the SBX account's ECS clusters are only for the SBX environment and the 'environment' argument is redundant."
    echo "  ${LIGHTGREEN}showecs ${LIGHTYELLOW}sbx security${NOCOLOR} : this will check the security groups on the SBX account's ECS clusters."
    echo ""
  elif [[ $cmd == 'cleanjenkinsagents' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- cleans up the disk space on the jenkins agents by running 'docker system prune'"
    echo ""
  elif [[ $cmd == 'latestmods' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- search github for the latest released version of modules in a terraform project"
    echo ""
  elif [[ $cmd == 'gpall' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- Run git pull recursively in projects dir"
    echo "- WARNING: This may create conflicts on local changes !!"
    echo ""
  elif [[ $cmd == 'tfarch' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- Prints out a list of all resources in a terraform project"
    echo "" 
  elif [[ $cmd == 'localssm' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- Shows a list of available EC2 instances and connects to the selected instance via SSM"
    echo "\n${GREEN}usage:${NOCOLOR}"
    echo "- ${LIGHTGREEN}localssm ${YELLOW}<instance>${NOCOLOR}"
    echo "\n${GREEN}arguments:${NOCOLOR}"
    echo "- [ ${YELLOW}instance${NOCOLOR} ] : ${LAV}optional${NOCOLOR} - instance id or private ip address of the desired instance to connect"
    echo ""
  elif [[ $cmd == 'bootstat' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- Checks the status of the EC2 instance Jenkins agents and shows bootstrap process statuses and outputs"
    echo "\n${GREEN}usage:${NOCOLOR}"
    echo "- ${LIGHTGREEN}bootstat ${YELLOW}<option>${NOCOLOR}"
    echo "\n${GREEN}options:${NOCOLOR}"
    echo "- [ ${YELLOW}--terminate-fails${NOCOLOR} ] : ${LAV}optional${NOCOLOR} - terminate instances that have failed the bootstrap process"
    echo ""
  elif [[ $cmd == 'instakill' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- Terminates the instance of the provided instance id"
    echo "\n${GREEN}usage:${NOCOLOR}"
    echo "- ${LIGHTGREEN}instakill ${YELLOW}<id>${NOCOLOR}"
    echo "\n${GREEN}arguments:${NOCOLOR}"
    echo "- [ ${YELLOW}id${NOCOLOR} ] : instance id of the desired instance to be terminated"
    echo ""
  elif [[ $cmd == 'gprm' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- merge the pull request on the current branch, return to the base branch of the pull request and perform a git pull"
    echo "\n${GREEN}usage:${NOCOLOR}"
    echo "- ${LIGHTGREEN}gprm ${YELLOW}<filter>${NOCOLOR}"
    echo "\n${GREEN}arguments:${NOCOLOR}"
    echo "- [ ${YELLOW}filter${NOCOLOR} ] : ${LAV}optional${NOCOLOR} - list of words which the desired project should include"
    echo "\n${GREEN}example:${NOCOLOR}"
    echo "  ${LIGHTGREEN}gprm${NOCOLOR} : if run from the branch of a project's directory that has an open and approved pull request, it will merge the pull request, checkout the target branch of the pull request, and delete the old branch."
    echo "  ${LIGHTGREEN}gprm ${YELLOW}cacao be tf${NOCOLOR} : this will search for a project that contains the words 'cacao', 'be', and 'tf' and perform the same steps as the example above."
    echo ""
  elif [[ $cmd == 'listf' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- list all local terraform projects"
    echo ""
  elif [[ $md == 'grlstf' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- search remote github for all terraform repositories"
    echo "\n${GREEN}usage:${NOCOLOR}"
    echo "- ${LIGHTGREEN}gprm ${YELLOW}<option>${NOCOLOR}"
    echo "\n${GREEN}arguments:${NOCOLOR}"
    echo "- [ ${YELLOW}--clean${NOCOLOR} ] : ${LAV}optional${NOCOLOR} - enable to only show list of terraform repositories"
    echo ""
  elif [[ $cmd == 'findtype' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- search through all projects and find all projects that use a specified module"
    echo "\n${GREEN}usage:${NOCOLOR}"
    echo "- ${LIGHTGREEN}findtype ${YELLOW}<resource type> <version>${NOCOLOR}"
    echo "\n${GREEN}arguments:${NOCOLOR}"
    echo "- [ ${YELLOW}resource type${NOCOLOR} ] : desired resource type to search for within the projects"
    echo "- [ ${YELLOW}version${NOCOLOR} ] : ${LAV}optional${NOCOLOR} - highlights any results that match this parameter"
    echo "\n${GREEN}resource type options:${NOCOLOR}"
    echo "- [${LIGHTGREEN}s3, rds, iam, sqs, ecs, glue, dynamodb, lambda, redshift, sg${NOCOLOR}]"
    echo "\n${GREEN}example:${NOCOLOR}"
    echo "  ${LIGHTGREEN}findtype${NOCOLOR} rds : searchs through every project for usages of the RDS module"
    echo ""
  elif [[ $cmd == 'getprojectbranch' ]]; then
    echo "\n${GREEN}description:${NOCOLOR}"
    echo "- print the currently checked out branch of a project"
    echo "\n${GREEN}usage:${NOCOLOR}"
    echo "- ${LIGHTGREEN}getprojectbranch ${YELLOW}<project>${NOCOLOR}"
    echo "\n${GREEN}arguments:${NOCOLOR}"
    echo "- [ ${YELLOW}project${NOCOLOR} ] : name of the desired project on which to check the currently checked out branch"
    echo ""
  fi   
}